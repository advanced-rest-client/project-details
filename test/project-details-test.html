<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../chance/dist/chance.min.js"></script>
    <script src="data-helper.js"></script>
    <link rel="import" href="../../arc-models/request-model.html">
    <link rel="import" href="../../arc-models/project-model.html">
    <link rel="import" href="../../app-pouchdb/pouchdb.html">
    <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
    <link rel="import" href="../project-details.html">
  </head>
  <body>
    <request-model></request-model>
    <project-model></project-model>

    <test-fixture id="Basic">
      <template>
        <project-details></project-details>
      </template>
    </test-fixture>

    <test-fixture id="NoAuto">
      <template>
        <project-details no-auto-projects></project-details>
      </template>
    </test-fixture>

    <test-fixture id="Draggable">
      <template>
        <project-details draggable-enabled no-auto-projects></project-details>
      </template>
    </test-fixture>

    <script>
    /* global DataGenerator, chance, DataHelper */
    suite('Initialization', () => {
      suite('basic', function() {
        let element;
        setup(function() {
          element = fixture('NoAuto');
        });

        test('project is not set', function() {
          assert.isUndefined(element.project);
        });

        test('edit is false by default', function() {
          assert.isFalse(element.edit);
        });

        test('_hasRequests is false by default', function() {
          assert.isFalse(element._hasRequests);
        });
      });

      suite('basic - after initialization', function() {
        let project;
        suiteSetup(() => {
          return DataGenerator.insertSavedRequestData()
          .then((data) => {
            project = data.projects.find((item) => item.requests && item.requests.length);
            if (!project) {
              throw new Error('Test initialization failed. Projects were not generated.');
            }
          });
        });

        suiteTeardown(() => {
          return DataGenerator.destroySavedRequestData();
        });

        let element;
        setup((done) => {
          element = fixture('Basic');
          const list = element.shadowRoot.querySelector('project-requests-list');
          list.addEventListener('loading-requests-changed', function f(e) {
            if (e.detail.value) {
              return;
            }
            list.removeEventListener('loading-requests-changed', f);
            flush(() => done());
          });
          element.projectId = project._id;
        });

        test('Project is set', function() {
          assert.typeOf(element.project, 'object');
        });

        test('_hasRequests is computed', function() {
          assert.isTrue(element._hasRequests);
        });
      });
    });

    suite('_navigate()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Dispatches navigate event', () => {
        const spy = sinon.spy();
        element.addEventListener('navigate', spy);
        element._navigate('test');
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._navigate('test');
        assert.typeOf(e, 'customevent');
      });

      test('Event bubbles', () => {
        const e = element._navigate('test');
        assert.isTrue(e.bubbles);
      });

      test('Event is composed (not for Edge...)', () => {
        const e = element._navigate('test');
        if (typeof e.composed !== 'undefined') {
          assert.isTrue(e.composed);
        }
      });

      test('Detail is set', () => {
        const e = element._navigate('test');
        assert.equal(e.detail, 'test');
      });
    });

    suite('_dispatchProjectRead()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Dispatches project-read event', () => {
        const spy = sinon.spy();
        element.addEventListener('project-read', spy);
        element._dispatchProjectRead('test');
        assert.isTrue(spy.called);
        spy.args[0][0].detail.result.catch(() => {});
      });

      test('Returns the event', () => {
        const e = element._dispatchProjectRead('test');
        assert.typeOf(e, 'customevent');
        e.detail.result.catch(() => {});
      });

      test('Event bubbles', () => {
        const e = element._dispatchProjectRead('test');
        assert.isTrue(e.bubbles);
        e.detail.result.catch(() => {});
      });

      test('Event is composed (not for Edge...)', () => {
        const e = element._dispatchProjectRead('test');
        if (typeof e.composed !== 'undefined') {
          assert.isTrue(e.composed);
        }
        e.detail.result.catch(() => {});
      });

      test('Event is cancelable', () => {
        const e = element._dispatchProjectRead('test');
        assert.isTrue(e.cancelable);
        e.detail.result.catch(() => {});
      });

      test('Detail is set', () => {
        const e = element._dispatchProjectRead('test');
        assert.equal(e.detail.id, 'test');
        e.detail.result.catch(() => {});
      });
    });

    suite('_dispatchRequestRead()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Dispatches request-project-list event', () => {
        const spy = sinon.spy();
        element.addEventListener('request-project-list', spy);
        element._dispatchRequestRead('test');
        assert.isTrue(spy.called);
        spy.args[0][0].detail.result.catch(() => {});
      });

      test('Returns the event', () => {
        const e = element._dispatchRequestRead('test');
        assert.typeOf(e, 'customevent');
        e.detail.result.catch(() => {});
      });

      test('Event bubbles', () => {
        const e = element._dispatchRequestRead('test');
        assert.isTrue(e.bubbles);
        e.detail.result.catch(() => {});
      });

      test('Event is composed (not for Edge...)', () => {
        const e = element._dispatchRequestRead('test');
        if (typeof e.composed !== 'undefined') {
          assert.isTrue(e.composed);
        }
        e.detail.result.catch(() => {});
      });

      test('Event is cancelable', () => {
        const e = element._dispatchRequestRead('test');
        assert.isTrue(e.cancelable);
        e.detail.result.catch(() => {});
      });

      test('Detail is set', () => {
        const e = element._dispatchRequestRead('test');
        assert.equal(e.detail.id, 'test');
        e.detail.result.catch(() => {});
      });
    });

    suite('_dispatchProjectUpdate()', () => {
      function handler(e) {
        e.stopPropagation();
        e.preventDefault();
        e.detail.result = Promise.resolve();
      }
      function stopHandler(e) {
        e.stopPropagation();
      }
      let element;
      setup((done) => {
        element = fixture('Basic');
        element._handleProjectsError = () => {};
        flush(() => done());
      });

      teardown(() => {
        document.body.removeEventListener('project-object-changed', handler);
        document.body.removeEventListener('project-object-changed', stopHandler);
      });

      test('Calls _dispatch() with arguments', () => {
        document.body.addEventListener('project-object-changed', handler);
        const spy = sinon.spy(element, '_dispatch');
        const p = {_id: 'test-p'};
        element._dispatchProjectUpdate(p);
        assert.equal(spy.args[0][0], 'project-object-changed');
        assert.deepEqual(spy.args[0][1].project, p);
      });

      test('Returns promise from the event', () => {
        document.body.addEventListener('project-object-changed', handler);
        const p = {_id: 'test-p'};
        const result = element._dispatchProjectUpdate(p);
        assert.typeOf(result.then, 'function');
      });

      test('Rejects when no model', () => {
        document.body.addEventListener('project-object-changed', stopHandler);
        const p = {_id: 'test-p'};
        return element._dispatchProjectUpdate(p)
        .then(() => {
          throw new Error('Should not result');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Model event not handled.');
        });
      });
    });

    suite('_dispatchUndelete()', () => {
      let element;
      let list;
      setup((done) => {
        element = fixture('NoAuto');
        list = [];
        for (let i = 0; i < 5; i++) {
          list[i] = {
            _id: chance.guid({version: 5}),
            _rev: chance.guid({version: 5})
          };
        }
        element._handleProjectsError = () => {};
        flush(() => done());
      });

      test('Dispatches request-objects-undeleted event', () => {
        const spy = sinon.spy();
        element.addEventListener('request-objects-undeleted', spy);
        const e = element._dispatchUndelete(list);
        assert.isTrue(spy.called);
        e.detail.result.catch(() => {});
      });

      test('The event bubbles', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        assert.isTrue(data.bubbles);
        e.detail.result.catch(() => {});
      });

      test('The event is composed', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        if (typeof data.composed !== 'undefined') {
          assert.isTrue(data.composed);
        }
        e.detail.result.catch(() => {});
      });

      test('The event is cancelable', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        assert.isTrue(data.cancelable);
        e.detail.result.catch(() => {});
      });

      test('The event has "detail.type"', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e.detail;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        assert.equal(data.type, 'saved');
        e.detail.result.catch(() => {});
      });

      test('The event has "detail.items"', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e.detail;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        assert.typeOf(data.items, 'array');
        assert.lengthOf(data.items, 5);
        e.detail.result.catch(() => {});
      });

      test('The "detail.items" has _id and _rev', () => {
        let data;
        element.addEventListener('request-objects-undeleted', function f(e) {
          element.removeEventListener('request-objects-undeleted', f);
          data = e.detail;
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        const e = element._dispatchUndelete(list);
        assert.typeOf(data.items[0]._id, 'string');
        assert.typeOf(data.items[0]._rev, 'string');
        e.detail.result.catch(() => {});
      });
    });

    suite('revertDeleted()', () => {
      teardown(() => {
        return DataGenerator.destroySavedRequestData();
      });
      let element;
      let list;
      setup((done) => {
        element = fixture('NoAuto');
        list = [];
        for (let i = 0; i < 5; i++) {
          list[i] = {
            _id: chance.guid({version: 5}),
            _rev: chance.guid({version: 5})
          };
        }
        element._handleProjectsError = () => {};
        flush(() => done());
      });

      test('Does nothing when delete was not called before', function() {
        return element.revertDeleted(); // no error is thrown
      });

      test('Closes delete confirmation toast', function() {
        element.addEventListener('request-objects-undeleted', (e) => {
          e.stopPropagation();
        });
        element._latestDeleted = list;
        element.revertDeleted().catch(() => {});
        assert.isFalse(element.$.deleteToast.opened);
      });

      test('Calls _dispatchUndelete() with list of requests', function() {
        element.addEventListener('request-objects-undeleted', (e) => {
          e.stopPropagation();
        });
        element._latestDeleted = list;
        const spy = sinon.spy(element, '_dispatchUndelete');
        element.revertDeleted().catch(() => {});
        assert.isTrue(spy.called);
      });

      test('Opens error toast when no model', function() {
        element.addEventListener('request-objects-undeleted', (e) => {
          e.stopPropagation();
        });
        element._latestDeleted = list;
        return element.revertDeleted().catch(() => {
          assert.isTrue(element.$.noModel.opened);
        });
      });

      test('Handles event sending', function() {
        element.addEventListener('request-objects-undeleted', (e) => {
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
        element._latestDeleted = list;
        return element.revertDeleted();
      });

      test('Opens revertError toast', () => {
        element.addEventListener('request-objects-undeleted', (e) => {
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.reject(new Error('Test'));
        });
        element._latestDeleted = list;
        return element.revertDeleted().then(() => {
          assert.isTrue(element.$.revertError.opened);
        });
      });
    });

    suite('_onOpen()', () => {
      let element;
      setup(function(done) {
        element = fixture('NoAuto');
        element._handleProjectsError = () => {};
        flush(() => done());
      });

      test('Calls _navigate with arguments', () => {
        const spy = sinon.spy(element, '_navigate');
        element._onOpen({
          detail: {
            item: {
              _id: 'test-id'
            }
          }
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0].base, 'request');
        assert.equal(spy.args[0][0].type, 'saved');
        assert.equal(spy.args[0][0].id, 'test-id');
      });
    });

    suite('_onDelete()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Calls _delete with arguments', () => {
        const spy = sinon.spy(element, '_delete');
        const items = [{
          _id: 'test-id'
        }];
        element._onDelete({
          detail: {
            items
          }
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], items);
      });
    });

    suite('openExportAll()', () => {
      let element;
      setup(() => {
        element = fixture('NoAuto');
      });

      test('Calls _closeMainMenu()', () => {
        const spy = sinon.spy(element, '_closeMainMenu');
        element.openExportAll();
        assert.isTrue(spy.called);
      });

      test('Sets _exportOptionsOpened', () => {
        element.openExportAll();
        assert.isTrue(element._exportOptionsOpened);
      });

      test('Sets _exportItems', () => {
        const items = [{test: true}];
        const list = element.shadowRoot.querySelector('project-requests-list');
        list.requests = items;
        element.openExportAll();
        assert.deepEqual(element._exportItems, items);
      });
    });

    suite('_cancelExportOptions()', () => {
      let element;
      setup(() => {
        element = fixture('NoAuto');
        element._exportOptionsOpened = true;
        element._exportItems = true;
      });

      test('Sets _exportOptionsOpened', () => {
        element._cancelExportOptions();
        assert.isFalse(element._exportOptionsOpened);
      });

      test('Sets _exportItems', () => {
        element._cancelExportOptions();
        assert.isUndefined(element._exportItems);
      });
    });

    suite('_exportAllFile()', () => {
      function handler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve();
      }

      let element;
      setup((done) => {
        element = fixture('NoAuto');
        flush(() => {
          const node = element.shadowRoot.querySelector('project-requests-list');
          node.requests = DataGenerator.generateRequests({
            requestsSize: 2
          });
          done();
        });
        window.addEventListener('arc-data-export', handler);
      });

      teardown(() => {
        window.removeEventListener('arc-data-export', handler);
      });

      test('Calls _doExportItems()', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.isTrue(spy.called);
        return result;
      });

      test('First argument is true', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.deepEqual(spy.args[0][0], element.requests);
        return result;
      });

      test('Second argument has options', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.typeOf(spy.args[0][1].options, 'object');
        return result;
      });

      test('Options has file', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.equal(spy.args[0][1].options.file, element._generateFileName());
        return result;
      });

      test('Options has kind', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.equal(spy.args[0][1].options.kind, 'ARC#ProjectExport');
        return result;
      });

      test('Options has provider', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._exportAllFile();
        assert.equal(spy.args[0][1].options.provider, 'file');
        return result;
      });
    });

    suite('_acceptExportOptions()', () => {
      function handler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve();
      }

      let element;
      setup(() => {
        element = fixture('NoAuto');
        window.addEventListener('arc-data-export', handler);
      });

      teardown(() => {
        window.removeEventListener('arc-data-export', handler);
      });

      test('Sets _exportOptionsOpened', () => {
        const result = element._acceptExportOptions({
          detail: {
            options: {}
          }
        });
        assert.isFalse(element._exportOptionsOpened);
        return result;
      });

      test('Calls _doExportItems()', () => {
        const spy = sinon.spy(element, '_doExportItems');
        const result = element._acceptExportOptions({
          detail: {
            options: {}
          }
        });
        assert.isTrue(spy.called);
        return result;
      });
    });

    suite('_generateFileName()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Returns default name when no project', () => {
        const result = element._generateFileName();
        assert.equal(result, 'arc-project-export.json');
      });

      test('Returns project name', () => {
        element.project = {
          name: 'test name'
        };
        const result = element._generateFileName();
        assert.equal(result, 'test-name.json');
      });
    });

    suite('_onExport()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Sets _exportOptionsOpened', () => {
        element._onExport({detail: {}});
        assert.isTrue(element._exportOptionsOpened);
      });

      test('Sets _exportItems', () => {
        const items = [{test: true}];
        element._onExport({detail: {items}});
        assert.deepEqual(element._exportItems, items);
      });

      test('Sets _exportItems as default value', () => {
        element._onExport({detail: {}});
        assert.deepEqual(element._exportItems, []);
      });
    });

    suite('_deleteRequestDetails()', () => {
      let request;
      function handler(e) {
        e.preventDefault();
        e.stopPropagation();
        const items = e.detail.items;
        const result = {};
        items.forEach((id, index) => {
          result[id] = 'rev-' + index;
        });
        e.detail.result = Promise.resolve(result);
      }
      let element;
      setup(function() {
        element = fixture('NoAuto');
        request = DataGenerator.generateRequests({requestsSize: 1})[0];
        element.addEventListener('request-objects-deleted', handler);
      });

      teardown(() => {
        element.removeEventListener('request-objects-deleted', handler);
      });

      test('Closes details panel', () => {
        element.$.requestDetails.request = request;
        const result = element._deleteRequestDetails();
        assert.isFalse(element.detailsOpened);
        return result;
      });

      test('Calls _delete() with an argument', () => {
        element.$.requestDetails.request = request;
        const spy = sinon.spy(element, '_delete');
        const result = element._deleteRequestDetails();
        assert.deepEqual(spy.args[0][0], [request]);
        return result;
      });
    });

    suite('_updateDeletedRevs()', () => {
      let requests;
      let element;
      setup(function() {
        element = fixture('NoAuto');
        requests = DataGenerator.generateRequests({requestsSize: 3});
      });

      test('Returns list of updates', () => {
        const updates = {};
        updates[requests[0]._id] = 'test-rev';
        const result = element._updateDeletedRevs(requests, updates);
        assert.lengthOf(result, 1);
        assert.equal(result[0]._rev, 'test-rev');
      });
    });

    suite('toggleEdit()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Toggles "edit" property', () => {
        element.toggleEdit();
        assert.isTrue(element.edit);
      });

      test('Calls _closeMainMenu()', () => {
        const spy = sinon.spy(element, '_closeMainMenu');
        element.toggleEdit();
        assert.isTrue(spy.called);
      });

      test('_cancelEdit() cancels the edit', () => {
        element.edit = true;
        element._cancelEdit();
        assert.isFalse(element.edit);
      });
    });

    suite('_updateRequest()', () => {
      let element;
      setup(() => {
        element = fixture('NoAuto');
      });

      test('Rejects promise when not handled', () => {
        element.addEventListener('request-object-changed', function f(e) {
          element.removeEventListener('request-object-changed', f);
          e.stopPropagation();
        });
        return element._updateRequest({_id: 'test-id'})
        .then(() => {
          throw new Error('Should not resolve');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Model not found');
        });
      });

      test('Resolves the promise', () => {
        const updObj = {request: true};
        element.addEventListener('request-object-changed', function f(e) {
          element.removeEventListener('request-object-changed', f);
          e.stopPropagation();
          e.preventDefault();
          e.detail.result = Promise.resolve(updObj);
        });
        return element._updateRequest({_id: 'test-id'})
        .then((result) => {
          assert.deepEqual(result, updObj);
        });
      });
    });

    suite('_projectForRequests()', () => {
      let element;
      let projectId;
      suiteSetup(function() {
        return DataHelper.generateData()
        .then((result) => {
          projectId = result.projectId;
        });
      });

      suiteTeardown(function() {
        return DataGenerator.destroySavedRequestData();
      });

      setup(function() {
        element = fixture('Basic');
        element.projectId = projectId;
        return DataHelper.doneWhenLoaded(element);
      });

      test('Returns undefine dwhen no project data', () => {
        element.project = undefined;
        const result = element._projectForRequests([{_id: 'test'}]);
        assert.isUndefined(result);
      });

      test('Maps requests when project does not have one', () => {
        delete element.project.requests;
        const result = element._projectForRequests([{_id: 'test'}]);
        assert.deepEqual(result.requests, ['test']);
      });

      test('Returns the same requests', () => {
        const requests = element.requests;
        const result = element._projectForRequests(requests);
        assert.deepEqual(result.requests, requests.map((i) => i._id));
      });

      test('Returns only requests passed in the argument', () => {
        const requests = element.requests.slice(0, 2);
        const result = element._projectForRequests(requests);
        assert.deepEqual(result.requests, requests.map((i) => i._id));
      });
    });

    suite('_updateBulk()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
        element._updateRequest = () => Promise.resolve();
      });

      test('Returns a promise', () => {
        const result = element._updateBulk([{}]);
        assert.typeOf(result.then, 'function');
      });

      test('Calls _updateRequest() for each item', () => {
        const spy = sinon.spy(element, '_updateRequest');
        element._updateBulk([{}, {}]);
        assert.equal(spy.callCount, 2);
      });
    });

    suite('_deleteDialogResult()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
        element._updateBulk = () => Promise.resolve();
        element._delete = () => Promise.resolve();
        element._notifyDeleteProject = () => Promise.resolve();
      });

      test('Does nothing when dialog cancelled', () => {
        const spy = sinon.spy(element, '_updateBulk');
        return element._deleteDialogResult({
          detail: {
            canceled: true
          }
        })
        .then(() => {
          assert.isFalse(spy.called);
        });
      });

      test('Does nothing when dialog not confirmed', () => {
        const spy = sinon.spy(element, '_updateBulk');
        return element._deleteDialogResult({
          detail: {
            confirmed: false
          }
        })
        .then(() => {
          assert.isFalse(spy.called);
        });
      });

      test('Calls _updateBulk() when has requests that belongs to other projects', () => {
        const spy = sinon.spy(element, '_updateBulk');
        const node = element.shadowRoot.querySelector('project-requests-list');
        element.project = DataGenerator.createProjectObject();
        const requests = node.requests = DataGenerator.generateRequests({requestsSize: 6});
        requests.forEach((item) => {
          item.projects = ['test', element.project._id];
        });
        return element._deleteDialogResult({
          detail: {
            confirmed: true
          }
        })
        .then(() => {
          assert.deepEqual(spy.args[0][0], requests);
        });
      });

      test('Calls _delete() when requests has single project', () => {
        const spy = sinon.spy(element, '_delete');
        const node = element.shadowRoot.querySelector('project-requests-list');
        element.project = DataGenerator.createProjectObject();
        const requests = node.requests = DataGenerator.generateRequests({requestsSize: 6});
        requests.forEach((item) => {
          item.projects = [element.project._id];
        });
        return element._deleteDialogResult({
          detail: {
            confirmed: true
          }
        })
        .then(() => {
          assert.deepEqual(spy.args[0][0], requests);
        });
      });
    });

    class MockedDataTransfer {
      constructor() {
        this._data = {};
        this.effectAllowed = 'none';
        this.dropEffect = 'none';
      }
      setData(type, data) {
        this._data[type] = String(data);
      }
      getData(type) {
        return this._data[type] || '';
      }
      get types() {
        return Object.keys(this._data);
      }
    }

    suite('_dragoverHandler()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        flush(() => {
          const node = element.shadowRoot.querySelector('project-requests-list');
          node.requests = DataGenerator.generateRequests({
            requestsSize: 2
          });
          done();
        });
      });

      function createEvent(types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = {
          preventDefault: () => {
            e.defaultPrevented = true;
          },
          defaultPrevented: false,
          type: 'dragover',
          dataTransfer: new MockedDataTransfer(),
          path: []
        };
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragoverHandler();
        // no error
      });

      test('Ignores event when it is cancelled', () => {
        const e = createEvent();
        e.preventDefault();
        element._dragoverHandler(e);
        assert.equal(e.dataTransfer.dropEffect, 'none');
      });

      test('Ignores event when arc/request-object is not set', () => {
        const e = createEvent(['other']);
        element._dragoverHandler(e);
        assert.equal(e.dataTransfer.dropEffect, 'none');
      });

      test('Cancels the event', () => {
        const e = createEvent();
        element._dragoverHandler(e);
        assert.isTrue(e.defaultPrevented);
      });

      test('Calls _computeDropEffect()', () => {
        const spy = sinon.spy(element, '_computeDropEffect');
        const e = createEvent();
        element._dragoverHandler(e);
        assert.isTrue(spy.called);
      });

      test('Sets dropEffect on the event', () => {
        const e = createEvent();
        element._dragoverHandler(e);
        assert.equal(e.dataTransfer.dropEffect, 'copy');
      });
    });

    suite('_computeDropEffect()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      function createEvent(types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = {
          dataTransfer: new MockedDataTransfer()
        };
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        return e;
      }

      test('Returns "copy" by default', () => {
        const e = createEvent();
        const result = element._computeDropEffect(e);
        assert.equal(result, 'copy');
      });

      test('Returns "move" when configuration is set', () => {
        const e = createEvent();
        e.ctrlKey = true;
        e.dataTransfer.effectAllowed = 'copyMove';
        const result = element._computeDropEffect(e);
        assert.equal(result, 'move');
      });

      test('Returns "copy" when a history item', () => {
        const e = createEvent(['arc/request-object', 'arc/history-request']);
        e.ctrlKey = true;
        e.dataTransfer.effectAllowed = 'copyMove';
        const result = element._computeDropEffect(e);
        assert.equal(result, 'copy');
      });

      test('Returns "copy" when effectAllowed is not move', () => {
        const e = createEvent();
        e.ctrlKey = true;
        e.dataTransfer.effectAllowed = 'link';
        const result = element._computeDropEffect(e);
        assert.equal(result, 'copy');
      });
    });

    suite('_dropHandler()', () => {
      function projectHandler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve({});
      }

      function requestHandler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve();
      }

      suiteSetup(() => {
        document.body.addEventListener('project-object-changed', projectHandler);
        document.body.addEventListener('save-request', requestHandler);
      });

      suiteTeardown(() => {
        document.body.removeEventListener('project-object-changed', projectHandler);
        document.body.removeEventListener('save-request', requestHandler);
      });

      let element;
      setup(function(done) {
        element = fixture('Draggable');
        element.project = {
          _id: 'test-project'
        };
        flush(() => {
          const node = element.shadowRoot.querySelector('project-requests-list');
          node.requests = DataGenerator.generateRequests({
            requestsSize: 4
          });
          done();
        });
      });

      function dispatch(element, types, content) {
        if (!types) {
          types = ['arc/request-object'];
        }
        if (content === undefined) {
          content = '{"_id":"test-id", "_rev":"test-rev"}';
        }
        const e = new Event('drop', {cancelable: true});
        e.dataTransfer = new MockedDataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, content);
        });
        element.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dropHandler();
        // no error
      });

      test('Ignores event when arc/request-object is not set', () => {
        dispatch(element, ['other']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Calls _computeDropEffect()', () => {
        const spy = sinon.spy(element, '_computeDropEffect');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Calls _insertRequestAt()', () => {
        const spy = sinon.spy(element, '_insertRequestAt');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Sets drop order', () => {
        const spy = sinon.spy(element, '_insertRequestAt');
        dispatch(element);
        assert.equal(spy.args[0][0], element.requests.length);
      });

      test('Calls _handleMoveDrop()', () => {
        const spy = sinon.spy(element, '_handleMoveDrop');
        element._computeDropEffect = () => 'move';
        dispatch(element);
        assert.isTrue(spy.called);
      });
    });

    suite('_handleMoveDrop()', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });
      function createEvent(types) {
        const _types = types;
        const e = {
          dataTransfer: {
            types: Object.keys(types),
            getData: (type) => _types[type]
          }
        };
        return e;
      }

      test('Returns false when project id not found', () => {
        const e = createEvent({
          'arc-source/project-detail': 'test'
        });
        const result = element._handleMoveDrop(e, {
          projects: []
        });
        assert.isFalse(result);
      });

      test('Returns true when removing project from arc-source/project-menu', () => {
        const e = createEvent({
          'arc-source/project-menu': 'project-id'
        });
        const result = element._handleMoveDrop(e, {
          projects: ['project-id']
        });
        assert.isTrue(result);
      });

      test('Returns true when removing project from arc-source/project-detail', () => {
        const e = createEvent({
          'arc-source/project-detail': 'project-id'
        });
        const result = element._handleMoveDrop(e, {
          projects: ['project-id']
        });
        assert.isTrue(result);
      });

      test('Returns false when project is not set on request', () => {
        const e = createEvent({
          'arc-source/project-detail': 'project-id'
        });
        const result = element._handleMoveDrop(e, {
          projects: ['']
        });
        assert.isFalse(result);
      });
    });

    suite('_insertRequestAt()', () => {
      function projectHandler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve({});
      }

      function requestHandler(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve();
      }

      suiteSetup(() => {
        document.body.addEventListener('project-object-changed', projectHandler);
        document.body.addEventListener('save-request', requestHandler);
      });

      suiteTeardown(() => {
        document.body.removeEventListener('project-object-changed', projectHandler);
        document.body.removeEventListener('save-request', requestHandler);
      });

      let element;
      setup(function(done) {
        element = fixture('Draggable');
        element.project = {
          _id: 'test-project'
        };
        flush(() => {
          const node = element.shadowRoot.querySelector('project-requests-list');
          node.requests = DataGenerator.generateRequests({
            requestsSize: 4
          });
          done();
        });
      });

      test('Removes _rev from history object', () => {
        const request = DataGenerator.generateHistoryObject();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.isUndefined(request._rev);
        });
      });

      test('Regenerates _id on history object', () => {
        const request = DataGenerator.generateHistoryObject();
        const id = request._id;
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.typeOf(request._id, 'string');
          assert.notEqual(request._it, id);
        });
      });

      test('Adds default name', () => {
        const request = DataGenerator.generateHistoryObject();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.equal(request.name, 'Unnamed');
        });
      });

      test('Sets requests array on the project', () => {
        const request = DataGenerator.generateHistoryObject();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.deepEqual(element.project.requests, [request._id]);
        });
      });

      test('Adds request to the array', () => {
        element.project.requests = ['test'];
        const request = DataGenerator.generateSavedItem();
        return element._insertRequestAt(1, request)
        .then(() => {
          assert.deepEqual(element.project.requests, ['test', request._id]);
        });
      });

      test('Replaces request position', () => {
        const request = DataGenerator.generateSavedItem();
        element.project.requests = ['test', request._id, 'other'];
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.deepEqual(element.project.requests, [request._id, 'test', 'other']);
        });
      });

      test('Creates projects list on the request', () => {
        const request = DataGenerator.generateSavedItem();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.deepEqual(request.projects, [element.project._id]);
        });
      });

      test('Adds project to the list of projects', () => {
        const request = DataGenerator.generateSavedItem();
        request.projects = ['other'];
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.deepEqual(request.projects, ['other', element.project._id]);
        });
      });

      test('Calls _dispatchProjectUpdate()', () => {
        const spy = sinon.spy(element, '_dispatchProjectUpdate');
        const request = DataGenerator.generateSavedItem();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls _dispatch() for save-request', () => {
        const spy = sinon.spy(element, '_dispatch');
        const request = DataGenerator.generateSavedItem();
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.equal(spy.args[1][0], 'save-request');
          assert.deepEqual(spy.args[1][1].request, request);
        });
      });

      test('Won\'t call _dispatch() for save-request when project already set', () => {
        const spy = sinon.spy(element, '_dispatch');
        const request = DataGenerator.generateSavedItem();
        request.projects = [element.project._id];
        return element._insertRequestAt(0, request)
        .then(() => {
          assert.isUndefined(spy.args[1]);
        });
      });

      test('Call _dispatch() for save-request when forced', () => {
        const spy = sinon.spy(element, '_dispatch');
        const request = DataGenerator.generateSavedItem();
        request.projects = [element.project._id];
        return element._insertRequestAt(0, request, true)
        .then(() => {
          assert.typeOf(spy.args[1], 'array');
        });
      });
    });
    </script>

  </body>
</html>
